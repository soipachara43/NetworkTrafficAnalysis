"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var axis_utils_1 = require("../../utils/axis_utils");
var theme_1 = require("../../../../utils/themes/theme");
var utils_1 = require("../../state/utils");
var line_1 = require("./primitives/line");
var d3_utils_1 = require("../../../partition_chart/layout/utils/d3_utils");
var canvas_1 = require("../../../../renderers/canvas");
function renderGrids(ctx, props) {
    var axesGridLinesPositions = props.axesGridLinesPositions, axesSpecs = props.axesSpecs, chartDimensions = props.chartDimensions, chartTheme = props.chartTheme;
    canvas_1.withContext(ctx, function (ctx) {
        ctx.translate(chartDimensions.left, chartDimensions.top);
        axesGridLinesPositions.forEach(function (axisGridLinesPositions, axisId) {
            var axisSpec = utils_1.getSpecsById(axesSpecs, axisId);
            if (axisSpec && axisGridLinesPositions.length > 0) {
                var themeConfig = axis_utils_1.isVerticalGrid(axisSpec.position)
                    ? chartTheme.axes.gridLineStyle.vertical
                    : chartTheme.axes.gridLineStyle.horizontal;
                var axisSpecConfig = axisSpec.gridLineStyle;
                var gridLineStyle = axisSpecConfig ? theme_1.mergeGridLineConfigs(axisSpecConfig, themeConfig) : themeConfig;
                if (!gridLineStyle.stroke || !gridLineStyle.strokeWidth || gridLineStyle.strokeWidth < line_1.MIN_STROKE_WIDTH) {
                    return;
                }
                var strokeColor = d3_utils_1.stringToRGB(gridLineStyle.stroke);
                strokeColor.opacity =
                    gridLineStyle.opacity !== undefined ? strokeColor.opacity * gridLineStyle.opacity : strokeColor.opacity;
                var stroke = {
                    color: strokeColor,
                    width: gridLineStyle.strokeWidth,
                    dash: gridLineStyle.dash,
                };
                var lines = axisGridLinesPositions.map(function (position) {
                    return {
                        x1: position[0],
                        y1: position[1],
                        x2: position[2],
                        y2: position[3],
                    };
                });
                line_1.renderMultiLine(ctx, lines, stroke);
            }
        });
    });
}
exports.renderGrids = renderGrids;
//# sourceMappingURL=grids.js.map