"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var axis_utils_1 = require("../../../utils/axis_utils");
var commons_1 = require("../../../../../utils/commons");
var line_1 = require("../primitives/line");
var d3_utils_1 = require("../../../../partition_chart/layout/utils/d3_utils");
function renderTick(ctx, tick, props) {
    var _a = props.axisSpec, tickSize = _a.tickSize, position = _a.position, axisPosition = props.axisPosition, tickLineStyle = props.axisConfig.tickLineStyle;
    if (!tickLineStyle.visible || tickLineStyle.strokeWidth < line_1.MIN_STROKE_WIDTH) {
        return;
    }
    if (axis_utils_1.isVerticalAxis(position)) {
        renderVerticalTick(ctx, position, axisPosition.width, tickSize, tick.position, tickLineStyle);
    }
    else {
        renderHorizontalTick(ctx, position, axisPosition.height, tickSize, tick.position, tickLineStyle);
    }
}
exports.renderTick = renderTick;
function renderVerticalTick(ctx, position, axisWidth, tickSize, tickPosition, tickStyle) {
    var isLeftAxis = position === commons_1.Position.Left;
    var x1 = isLeftAxis ? axisWidth : 0;
    var x2 = isLeftAxis ? axisWidth - tickSize : tickSize;
    line_1.renderLine(ctx, { x1: x1, y1: tickPosition, x2: x2, y2: tickPosition }, {
        color: d3_utils_1.stringToRGB(tickStyle.stroke),
        width: tickStyle.strokeWidth,
    });
}
function renderHorizontalTick(ctx, position, axisHeight, tickSize, tickPosition, tickStyle) {
    var isTopAxis = position === commons_1.Position.Top;
    var y1 = isTopAxis ? axisHeight - tickSize : 0;
    var y2 = isTopAxis ? axisHeight : tickSize;
    line_1.renderLine(ctx, { x1: tickPosition, y1: y1, x2: tickPosition, y2: y2 }, {
        color: d3_utils_1.stringToRGB(tickStyle.stroke),
        width: tickStyle.strokeWidth,
    });
}
//# sourceMappingURL=tick.js.map