"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var re_reselect_1 = __importDefault(require("re-reselect"));
var get_settings_specs_1 = require("../../../../state/selectors/get_settings_specs");
var index_1 = require("../../../index");
var get_computed_scales_1 = require("./get_computed_scales");
var compute_chart_dimensions_1 = require("./compute_chart_dimensions");
var is_histogram_mode_enabled_1 = require("./is_histogram_mode_enabled");
var is_brush_available_1 = require("./is_brush_available");
var getLastDragSelector = function (state) { return state.interactions.pointer.lastDrag; };
function hasDragged(prevProps, nextProps) {
    if (nextProps === null) {
        return false;
    }
    if (!nextProps.settings || !nextProps.settings.onBrushEnd) {
        return false;
    }
    var prevLastDrag = prevProps !== null ? prevProps.lastDrag : null;
    var nextLastDrag = nextProps !== null ? nextProps.lastDrag : null;
    if (prevLastDrag === null && nextLastDrag !== null) {
        return true;
    }
    if (prevLastDrag !== null && nextLastDrag !== null && prevLastDrag.end.time !== nextLastDrag.end.time) {
        return true;
    }
    return false;
}
function createOnBrushEndCaller() {
    var prevProps = null;
    var selector = null;
    return function (state) {
        if (selector === null && state.chartType === index_1.ChartTypes.XYAxis) {
            if (!is_brush_available_1.isBrushAvailableSelector(state)) {
                selector = null;
                prevProps = null;
                return;
            }
            selector = re_reselect_1.default([
                getLastDragSelector,
                get_settings_specs_1.getSettingsSpecSelector,
                get_computed_scales_1.getComputedScalesSelector,
                compute_chart_dimensions_1.computeChartDimensionsSelector,
                is_histogram_mode_enabled_1.isHistogramModeEnabledSelector,
            ], function (lastDrag, settings, computedScales, _a, histogramMode) {
                var chartDimensions = _a.chartDimensions;
                var nextProps = {
                    lastDrag: lastDrag,
                    settings: settings,
                };
                if (lastDrag !== null && hasDragged(prevProps, nextProps)) {
                    if (settings && settings.onBrushEnd) {
                        var startPos = lastDrag.start.position.x - chartDimensions.left;
                        var endPos = lastDrag.end.position.x - chartDimensions.left;
                        var chartMax = chartDimensions.width;
                        if (settings.rotation === -90 || settings.rotation === 90) {
                            startPos = lastDrag.start.position.y - chartDimensions.top;
                            endPos = lastDrag.end.position.y - chartDimensions.top;
                            chartMax = chartDimensions.height;
                        }
                        var minPos = Math.max(Math.min(startPos, endPos), 0);
                        var maxPos = Math.min(Math.max(startPos, endPos), chartMax);
                        if (settings.rotation === -90 || settings.rotation === 180) {
                            minPos = chartMax - minPos;
                            maxPos = chartMax - maxPos;
                        }
                        if (maxPos === minPos) {
                            return;
                        }
                        var xScale = computedScales.xScale;
                        var offset = histogramMode ? 0 : -(xScale.bandwidth + xScale.bandwidthPadding) / 2;
                        var minPosScaled = xScale.invert(minPos + offset);
                        var maxPosScaled = xScale.invert(maxPos + offset);
                        var minValue = Math.max(Math.min(minPosScaled, maxPosScaled), xScale.domain[0]);
                        var maxValue = Math.min(Math.max(minPosScaled, maxPosScaled), xScale.domain[1]);
                        settings.onBrushEnd(minValue, maxValue);
                    }
                }
                prevProps = nextProps;
            })({
                keySelector: function (state) { return state.chartId; },
            });
        }
        if (selector) {
            selector(state);
        }
    };
}
exports.createOnBrushEndCaller = createOnBrushEndCaller;
//# sourceMappingURL=on_brush_end_caller.js.map