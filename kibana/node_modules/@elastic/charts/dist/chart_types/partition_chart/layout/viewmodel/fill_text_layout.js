"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var geometry_1 = require("../geometry");
var math_1 = require("../utils/math");
var circline_geometry_1 = require("../circline_geometry");
var d3_utils_1 = require("../utils/d3_utils");
var calcs_1 = require("../utils/calcs");
var INFINITY_RADIUS = 1e4;
function ringSectorStartAngle(d) {
    return math_1.trueBearingToStandardPositionAngle(d.x0 + Math.max(0, d.x1 - d.x0 - math_1.TAU / 2) / 2);
}
function ringSectorEndAngle(d) {
    return math_1.trueBearingToStandardPositionAngle(d.x1 - Math.max(0, d.x1 - d.x0 - math_1.TAU / 2) / 2);
}
function ringSectorInnerRadius(innerRadius, ringThickness) {
    return function (d) { return innerRadius + d.y0 * ringThickness; };
}
function ringSectorOuterRadius(innerRadius, ringThickness) {
    return function (d) { return innerRadius + (d.y0 + 1) * ringThickness; };
}
function angleToCircline(midRadius, alpha, direction) {
    var sectorRadiusLineX = Math.cos(alpha) * midRadius;
    var sectorRadiusLineY = Math.sin(alpha) * midRadius;
    var normalAngle = alpha + (direction * Math.PI) / 2;
    var x = sectorRadiusLineX + INFINITY_RADIUS * Math.cos(normalAngle);
    var y = sectorRadiusLineY + INFINITY_RADIUS * Math.sin(normalAngle);
    var sectorRadiusCircline = { x: x, y: y, r: INFINITY_RADIUS, inside: false, from: 0, to: math_1.TAU };
    return sectorRadiusCircline;
}
function nodeId(node) {
    return node.x0 + "|" + node.y0;
}
exports.nodeId = nodeId;
function rectangleConstruction(node) {
    return {
        x0: node.x0,
        y0: node.y0px,
        x1: node.x1,
        y1: node.y1px,
    };
}
exports.rectangleConstruction = rectangleConstruction;
function ringSectorConstruction(config, innerRadius, ringThickness) {
    return function (ringSector) {
        var circlePadding = config.circlePadding, radialPadding = config.radialPadding, fillOutside = config.fillOutside, radiusOutside = config.radiusOutside, fillRectangleWidth = config.fillRectangleWidth, fillRectangleHeight = config.fillRectangleHeight;
        var innerR = (fillOutside ? ringSectorOuterRadius : ringSectorInnerRadius)(innerRadius, ringThickness)(ringSector) +
            circlePadding * 2;
        var outerR = Math.max(innerR, ringSectorOuterRadius(innerRadius, ringThickness)(ringSector) - circlePadding + (fillOutside ? radiusOutside : 0));
        var startAngle = ringSectorStartAngle(ringSector);
        var endAngle = ringSectorEndAngle(ringSector);
        var innerCircline = { x: 0, y: 0, r: innerR, inside: true, from: 0, to: math_1.TAU };
        var outerCircline = { x: 0, y: 0, r: outerR, inside: false, from: 0, to: math_1.TAU };
        var midRadius = (innerR + outerR) / 2;
        var sectorStartCircle = angleToCircline(midRadius, startAngle - radialPadding, -1);
        var sectorEndCircle = angleToCircline(midRadius, endAngle + radialPadding, 1);
        var outerRadiusFromRectangleWidth = fillRectangleWidth / 2;
        var outerRadiusFromRectanglHeight = fillRectangleHeight / 2;
        var fullCircle = ringSector.x0 === 0 && ringSector.x1 === math_1.TAU;
        var sectorCirclines = __spread((fullCircle && innerRadius === 0 ? [] : [innerCircline]), [
            outerCircline
        ], (fullCircle ? [] : [sectorStartCircle, sectorEndCircle]));
        var rectangleCirclines = outerRadiusFromRectangleWidth === Infinity && outerRadiusFromRectanglHeight === Infinity
            ? []
            : [
                { x: INFINITY_RADIUS - outerRadiusFromRectangleWidth, y: 0, r: INFINITY_RADIUS, inside: true },
                { x: -INFINITY_RADIUS + outerRadiusFromRectangleWidth, y: 0, r: INFINITY_RADIUS, inside: true },
                { x: 0, y: INFINITY_RADIUS - outerRadiusFromRectanglHeight, r: INFINITY_RADIUS, inside: true },
                { x: 0, y: -INFINITY_RADIUS + outerRadiusFromRectanglHeight, r: INFINITY_RADIUS, inside: true },
            ];
        return __spread(sectorCirclines, rectangleCirclines);
    };
}
exports.ringSectorConstruction = ringSectorConstruction;
function makeRowCircline(cx, cy, radialOffset, rotation, fontSize, offsetSign) {
    var r = INFINITY_RADIUS;
    var offset = (offsetSign * fontSize) / 2;
    var topRadius = r - offset;
    var x = cx + topRadius * Math.cos(-rotation + math_1.TAU / 4);
    var y = cy + topRadius * Math.cos(-rotation + math_1.TAU / 2);
    var circline = { r: r + radialOffset, x: x, y: y };
    return circline;
}
function getSectorRowGeometry(ringSector, cx, cy, totalRowCount, linePitch, rowIndex, fontSize, rotation) {
    var offset = (totalRowCount / 2) * fontSize
        + fontSize / 2
        - linePitch * rowIndex;
    var topCircline = makeRowCircline(cx, cy, offset, rotation, fontSize, 1);
    var bottomCircline = makeRowCircline(cx, cy, offset, rotation, fontSize, -1);
    var midCircline = makeRowCircline(cx, cy, offset, rotation, 0, 0);
    var valid1 = circline_geometry_1.conjunctiveConstraint(ringSector, Object.assign({}, topCircline, { from: 0, to: math_1.TAU }))[0];
    if (!valid1)
        return { rowCentroidX: cx, rowCentroidY: cy, maximumRowLength: 0 };
    var valid2 = circline_geometry_1.conjunctiveConstraint(ringSector, Object.assign({}, bottomCircline, { from: 0, to: math_1.TAU }))[0];
    if (!valid2)
        return { rowCentroidX: cx, rowCentroidY: cy, maximumRowLength: 0 };
    var from = Math.max(valid1.from, valid2.from);
    var to = Math.min(valid1.to, valid2.to);
    var midAngle = (from + to) / 2;
    var cheapTangent = Math.max(0, to - from);
    var rowCentroidX = midCircline.r * Math.cos(midAngle) + midCircline.x;
    var rowCentroidY = midCircline.r * Math.sin(midAngle) + midCircline.y;
    var maximumRowLength = cheapTangent * INFINITY_RADIUS;
    return { rowCentroidX: rowCentroidX, rowCentroidY: rowCentroidY, maximumRowLength: maximumRowLength };
}
exports.getSectorRowGeometry = getSectorRowGeometry;
function getRectangleRowGeometry(container, cx, cy, totalRowCount, linePitch, rowIndex, fontSize) {
    var wordSpacing = getWordSpacing(fontSize);
    var x0 = container.x0 + wordSpacing;
    var y0 = container.y0 + linePitch / 2;
    var x1 = container.x1 - wordSpacing;
    var y1 = container.y1 - linePitch / 2;
    var offset = (totalRowCount / 2) * fontSize
        + fontSize / 2
        - linePitch * rowIndex;
    var rowCentroidX = cx;
    var rowCentroidY = cy - offset;
    return {
        rowCentroidX: rowCentroidX,
        rowCentroidY: -rowCentroidY,
        maximumRowLength: rowCentroidY - linePitch / 2 < y0 || rowCentroidY + linePitch / 2 > y1 ? 0 : x1 - x0,
    };
}
exports.getRectangleRowGeometry = getRectangleRowGeometry;
function rowSetComplete(rowSet, measuredBoxes) {
    return !rowSet.rows.some(function (r) { return isNaN(r.length); }) && !measuredBoxes.length;
}
function identityRowSet() {
    return {
        id: '',
        rows: [],
        fontSize: NaN,
        fillTextColor: '',
        rotation: NaN,
    };
}
function getAllBoxes(rawTextGetter, valueGetter, valueFormatter, sizeInvariantFontShorthand, valueFont, node) {
    return rawTextGetter(node)
        .split(' ')
        .map(function (text) { return (__assign({ text: text }, sizeInvariantFontShorthand)); })
        .concat(valueFormatter(valueGetter(node))
        .split(' ')
        .map(function (text) { return (__assign(__assign({ text: text }, sizeInvariantFontShorthand), valueFont)); }));
}
function getWordSpacing(fontSize) {
    return fontSize / 4;
}
function fill(config, layers, fontSizes, measure, rawTextGetter, valueGetter, formatter, textFillOrigins, shapeConstructor, getShapeRowGeometry, getRotation) {
    return function (node, index) {
        var maxRowCount = config.maxRowCount, fillLabel = config.fillLabel;
        var layer = layers[node.depth - 1] || {};
        var _a = Object.assign({ fontFamily: config.fontFamily, fontWeight: 'normal' }, fillLabel, { valueFormatter: formatter }, layer.fillLabel, layer.shape), textColor = _a.textColor, textInvertible = _a.textInvertible, fontStyle = _a.fontStyle, fontVariant = _a.fontVariant, fontFamily = _a.fontFamily, fontWeight = _a.fontWeight, valueFormatter = _a.valueFormatter;
        var valueFont = Object.assign({ fontFamily: config.fontFamily, fontWeight: 'normal' }, config.fillLabel && config.fillLabel.valueFont, fillLabel, fillLabel.valueFont, layer.fillLabel, layer.fillLabel && layer.fillLabel.valueFont);
        var specifiedTextColorIsDark = calcs_1.colorIsDark(textColor);
        var shapeFillColor = node.fillColor;
        var _b = d3_utils_1.stringToRGB(textColor), tr = _b.r, tg = _b.g, tb = _b.b, to = _b.opacity;
        var fontSizeIndex = fontSizes.length - 1;
        var sizeInvariantFont = {
            fontStyle: fontStyle,
            fontVariant: fontVariant,
            fontWeight: fontWeight,
            fontFamily: fontFamily,
        };
        var allBoxes = getAllBoxes(rawTextGetter, valueGetter, valueFormatter, sizeInvariantFont, valueFont, node);
        var rowSet = identityRowSet();
        var completed = false;
        var rotation = getRotation(node);
        var container = shapeConstructor(node);
        var _c = __read(textFillOrigins[index], 2), cx = _c[0], cy = _c[1];
        var _loop_1 = function () {
            var fontSize = fontSizes[fontSizeIndex];
            var wordSpacing = getWordSpacing(fontSize);
            var measurements = measure(fontSize, allBoxes);
            var allMeasuredBoxes = measurements.map(function (_a, i) {
                var width = _a.width, emHeightDescent = _a.emHeightDescent, emHeightAscent = _a.emHeightAscent;
                return (__assign(__assign({ width: width, verticalOffset: -(emHeightDescent + emHeightAscent) / 2, wordBeginning: NaN }, allBoxes[i]), { fontSize: fontSize }));
            });
            var linePitch = fontSize;
            var targetRowCount = 0;
            var measuredBoxes = allMeasuredBoxes.slice();
            var innerCompleted = false;
            while (++targetRowCount <= maxRowCount && !innerCompleted) {
                measuredBoxes = allMeasuredBoxes.slice();
                var backgroundIsDark = calcs_1.colorIsDark(shapeFillColor);
                var inverseForContrast = textInvertible && specifiedTextColorIsDark === backgroundIsDark;
                rowSet = {
                    id: nodeId(node),
                    fontSize: fontSize,
                    fillTextColor: inverseForContrast
                        ? to === undefined
                            ? "rgb(" + (255 - tr) + ", " + (255 - tg) + ", " + (255 - tb) + ")"
                            : "rgba(" + (255 - tr) + ", " + (255 - tg) + ", " + (255 - tb) + ", " + to + ")"
                        : textColor,
                    rotation: rotation,
                    rows: __spread(Array(targetRowCount)).map(function () { return ({
                        rowWords: [],
                        rowCentroidX: NaN,
                        rowCentroidY: NaN,
                        maximumLength: NaN,
                        length: NaN,
                    }); }),
                };
                var currentRowIndex = 0;
                while (currentRowIndex < targetRowCount) {
                    var currentRow = rowSet.rows[currentRowIndex];
                    var currentRowWords = currentRow.rowWords;
                    var _a = getShapeRowGeometry(container, cx, cy, targetRowCount, linePitch, currentRowIndex, fontSize, rotation), maximumRowLength = _a.maximumRowLength, rowCentroidX = _a.rowCentroidX, rowCentroidY = _a.rowCentroidY;
                    currentRow.rowCentroidX = rowCentroidX;
                    currentRow.rowCentroidY = rowCentroidY;
                    currentRow.maximumLength = maximumRowLength;
                    var currentRowLength = 0;
                    var rowHasRoom = true;
                    while (measuredBoxes.length && rowHasRoom) {
                        var currentBox = measuredBoxes[0];
                        var wordBeginning = currentRowLength;
                        currentRowLength += currentBox.width + wordSpacing;
                        if (currentRowLength <= currentRow.maximumLength) {
                            currentRowWords.push(Object.assign({}, currentBox, { wordBeginning: wordBeginning }));
                            currentRow.length = currentRowLength;
                            measuredBoxes.shift();
                        }
                        else {
                            rowHasRoom = false;
                        }
                    }
                    currentRowIndex++;
                }
                innerCompleted = rowSetComplete(rowSet, measuredBoxes);
            }
            {
                completed = !measuredBoxes.length;
                if (!completed) {
                    fontSizeIndex -= 1;
                }
            }
        };
        while (!completed && fontSizeIndex >= 0) {
            _loop_1();
        }
        rowSet.rows = rowSet.rows.filter(function (r) { return completed && !isNaN(r.length); });
        return rowSet;
    };
}
function inSectorRotation(horizontalTextEnforcer, horizontalTextAngleThreshold) {
    return function (node) {
        var rotation = math_1.trueBearingToStandardPositionAngle((node.x0 + node.x1) / 2);
        if (Math.abs(node.x1 - node.x0) > horizontalTextAngleThreshold && horizontalTextEnforcer > 0)
            rotation = rotation * (1 - horizontalTextEnforcer);
        if (math_1.TAU / 4 < rotation && rotation < (3 * math_1.TAU) / 4)
            rotation = geometry_1.wrapToTau(rotation - math_1.TAU / 2);
        return rotation;
    };
}
exports.inSectorRotation = inSectorRotation;
function fillTextLayout(measure, rawTextGetter, valueGetter, valueFormatter, childNodes, config, layers, textFillOrigins, shapeConstructor, getShapeRowGeometry, getRotation) {
    var minFontSize = config.minFontSize, maxFontSize = config.maxFontSize, idealFontSizeJump = config.idealFontSizeJump;
    var fontSizeMagnification = maxFontSize / minFontSize;
    var fontSizeJumpCount = Math.round(math_1.logarithm(idealFontSizeJump, fontSizeMagnification));
    var realFontSizeJump = Math.pow(fontSizeMagnification, 1 / fontSizeJumpCount);
    var fontSizes = [];
    for (var i = 0; i <= fontSizeJumpCount; i++) {
        var fontSize = Math.round(minFontSize * Math.pow(realFontSizeJump, i));
        if (fontSizes.indexOf(fontSize) === -1) {
            fontSizes.push(fontSize);
        }
    }
    return childNodes.map(fill(config, layers, fontSizes, measure, rawTextGetter, valueGetter, valueFormatter, textFillOrigins, shapeConstructor, getShapeRowGeometry, getRotation));
}
exports.fillTextLayout = fillTextLayout;
//# sourceMappingURL=fill_text_layout.js.map