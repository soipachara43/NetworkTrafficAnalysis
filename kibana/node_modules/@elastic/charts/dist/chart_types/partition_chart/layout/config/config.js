"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var palettes_1 = require("../../../../mocks/hierarchical/palettes");
var config_types_1 = require("../types/config_types");
var math_1 = require("../utils/math");
var types_1 = require("../types/types");
var group_by_rollup_1 = require("../utils/group_by_rollup");
var log10 = Math.log(10);
function significantDigitCount(d) {
    var n = Math.abs(parseFloat(String(d).replace('.', '')));
    if (n == 0)
        return 0;
    while (n != 0 && n % 10 == 0)
        n /= 10;
    return Math.floor(Math.log(n) / log10) + 1;
}
function sumValueGetter(node) {
    return node[group_by_rollup_1.AGGREGATE_KEY];
}
exports.sumValueGetter = sumValueGetter;
function percentValueGetter(node) {
    return (100 * node[group_by_rollup_1.AGGREGATE_KEY]) / node.parent[group_by_rollup_1.STATISTICS_KEY].globalAggregate;
}
exports.percentValueGetter = percentValueGetter;
function ratioValueGetter(node) {
    return node[group_by_rollup_1.AGGREGATE_KEY] / node.parent[group_by_rollup_1.STATISTICS_KEY].globalAggregate;
}
exports.ratioValueGetter = ratioValueGetter;
exports.VALUE_GETTERS = Object.freeze({ percent: percentValueGetter, ratio: ratioValueGetter });
function defaultFormatter(d) {
    return Math.abs(d) >= 10000000 || Math.abs(d) < 0.001
        ? d.toExponential(Math.min(2, Math.max(0, significantDigitCount(d) - 1)))
        : d.toLocaleString(void 0, {
            maximumSignificantDigits: 4,
            maximumFractionDigits: 3,
            useGrouping: true,
        });
}
function percentFormatter(d) {
    return Math.round(d) + "%";
}
exports.percentFormatter = percentFormatter;
var fontSettings = {
    fontFamily: {
        dflt: 'Sans-Serif',
        type: 'string',
    },
    fontSize: { dflt: 12, min: 4, max: 32, type: 'number' },
    fontStyle: {
        dflt: 'normal',
        type: 'string',
        values: types_1.FONT_STYLES,
    },
    fontVariant: {
        dflt: 'normal',
        type: 'string',
        values: types_1.FONT_VARIANTS,
    },
    fontWeight: { dflt: 400, min: 100, max: 900, type: 'number' },
};
var valueFont = {
    type: 'group',
    values: {
        fontWeight: fontSettings.fontWeight,
        fontStyle: fontSettings.fontStyle,
        fontVariant: fontSettings.fontVariant,
    },
};
exports.configMetadata = {
    width: { dflt: 300, min: 0, max: 1024, type: 'number', reconfigurable: false },
    height: { dflt: 150, min: 0, max: 1024, type: 'number', reconfigurable: false },
    margin: {
        type: 'group',
        values: {
            left: { dflt: 0, min: -0.25, max: 0.25, type: 'number' },
            right: { dflt: 0, min: -0.25, max: 0.25, type: 'number' },
            top: { dflt: 0, min: -0.25, max: 0.25, type: 'number' },
            bottom: { dflt: 0, min: -0.25, max: 0.25, type: 'number' },
        },
    },
    outerSizeRatio: new config_types_1.Numeric({
        dflt: 1 / math_1.GOLDEN_RATIO,
        min: 0.25,
        max: 1,
        reconfigurable: true,
        documentation: 'The diameter of the entire circle, relative to the smaller of the usable rectangular size (smaller of width/height minus the margins)',
    }),
    emptySizeRatio: new config_types_1.Numeric({
        dflt: 0,
        min: 0,
        max: 0.8,
        reconfigurable: true,
        documentation: 'The diameter of the inner circle, relative to `outerSizeRatio`',
    }),
    clockwiseSectors: {
        dflt: true,
        type: 'boolean',
        documentation: 'Largest to smallest sectors are positioned in a clockwise order',
    },
    specialFirstInnermostSector: {
        dflt: true,
        type: 'boolean',
        documentation: 'Starts placement with the second largest slice, for the innermost pie/ring',
    },
    fontFamily: {
        dflt: 'Sans-Serif',
        type: 'string',
    },
    minFontSize: { dflt: 8, min: 0.1, max: 8, type: 'number', reconfigurable: true },
    maxFontSize: { dflt: 64, min: 0.1, max: 64, type: 'number' },
    idealFontSizeJump: {
        dflt: 1.05,
        min: 1.05,
        max: math_1.GOLDEN_RATIO,
        type: 'number',
        reconfigurable: false,
    },
    partitionLayout: {
        dflt: config_types_1.PartitionLayout.sunburst,
        type: 'string',
        values: Object.keys(config_types_1.PartitionLayout),
    },
    circlePadding: { dflt: 2, min: 0, max: 8, type: 'number' },
    radialPadding: { dflt: math_1.TAU / 360, min: 0.0, max: 0.035, type: 'number' },
    horizontalTextAngleThreshold: { dflt: math_1.TAU / 12, min: 0, max: math_1.TAU, type: 'number' },
    horizontalTextEnforcer: { dflt: 1, min: 0, max: 1, type: 'number' },
    maxRowCount: { dflt: 12, min: 1, max: 16, type: 'number' },
    fillOutside: { dflt: false, type: 'boolean' },
    radiusOutside: { dflt: 128, min: 0, max: 1024, type: 'number' },
    fillRectangleWidth: { dflt: Infinity, reconfigurable: false, type: 'number' },
    fillRectangleHeight: { dflt: Infinity, reconfigurable: false, type: 'number' },
    fillLabel: {
        type: 'group',
        values: __assign(__assign({ textColor: { dflt: '#000000', type: 'color' }, textInvertible: { dflt: false, type: 'boolean' } }, fontSettings), { valueGetter: {
                dflt: sumValueGetter,
                type: 'function',
            }, valueFormatter: {
                dflt: defaultFormatter,
                type: 'function',
            }, valueFont: valueFont }),
    },
    linkLabel: {
        type: 'group',
        values: __assign(__assign({ maximumSection: {
                dflt: 10,
                min: 0,
                max: 10000,
                type: 'number',
                reconfigurable: true,
                documentation: 'Uses linked labels below this limit of the outer sector arc length (in pixels)',
            } }, fontSettings), { gap: { dflt: 10, min: 6, max: 16, type: 'number' }, spacing: { dflt: 2, min: 0, max: 16, type: 'number' }, horizontalStemLength: { dflt: 10, min: 6, max: 16, type: 'number' }, radiusPadding: { dflt: 10, min: 6, max: 16, type: 'number' }, lineWidth: { dflt: 1, min: 0.1, max: 2, type: 'number' }, maxCount: {
                dflt: 36,
                min: 2,
                max: 64,
                type: 'number',
                documentation: 'Limits the total count of linked labels. The first N largest slices are kept.',
            }, textColor: { dflt: '#000000', type: 'color' }, textInvertible: { dflt: false, type: 'boolean' }, textOpacity: { dflt: 1, min: 0, max: 1, type: 'number' }, minimumStemLength: {
                dflt: 0,
                min: 0,
                max: 16,
                type: 'number',
                reconfigurable: false,
            }, stemAngle: {
                dflt: math_1.TAU / 8,
                min: 0,
                max: math_1.TAU,
                type: 'number',
                reconfigurable: false,
            }, valueFont: valueFont }),
    },
    backgroundColor: { dflt: '#ffffff', type: 'color' },
    sectorLineWidth: { dflt: 1, min: 0, max: 4, type: 'number' },
    sectorLineStroke: { dflt: 'white', type: 'string' },
    colors: { dflt: 'turbo', type: 'palette', values: Object.keys(palettes_1.palettes) },
    palettes: { dflt: palettes_1.palettes, type: 'palettes', reconfigurable: false },
};
function configMap(mapper, configMetadata) {
    var result = Object.assign.apply(Object, __spread([{}], Object.entries(configMetadata).map(function (_a) {
        var _b, _c;
        var _d = __read(_a, 2), k = _d[0], v = _d[1];
        if (v.type === 'group') {
            return _b = {}, _b[k] = configMap(mapper, v.values), _b;
        }
        else {
            return _c = {}, _c[k] = mapper(v), _c;
        }
    })));
    return result;
}
exports.config = configMap(function (item) { return item.dflt; }, exports.configMetadata);
//# sourceMappingURL=config.js.map