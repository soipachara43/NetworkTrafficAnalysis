"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var math_1 = require("../utils/math");
var geometry_1 = require("../geometry");
function linkTextLayout(measure, config, nodesWithoutRoom, currentY, anchorRadius, rawTextGetter, valueGetter, valueFormatter) {
    var linkLabel = config.linkLabel;
    var maxDepth = nodesWithoutRoom.reduce(function (p, n) { return Math.max(p, n.depth); }, 0);
    var yRelativeIncrement = Math.sin(linkLabel.stemAngle) * linkLabel.minimumStemLength;
    var rowPitch = linkLabel.fontSize + linkLabel.spacing;
    return nodesWithoutRoom
        .filter(function (n) { return n.depth === maxDepth; })
        .sort(function (n1, n2) { return Math.abs(n2.x0 - n2.x1) - Math.abs(n1.x0 - n1.x1); })
        .slice(0, linkLabel.maxCount)
        .sort(function (n1, n2) {
        var mid1 = geometry_1.meanAngle(n1.x0, n1.x1);
        var mid2 = geometry_1.meanAngle(n2.x0, n2.x1);
        var dist1 = Math.min(Math.abs(mid1 - math_1.TAU / 4), Math.abs(mid1 - (3 * math_1.TAU) / 4));
        var dist2 = Math.min(Math.abs(mid2 - math_1.TAU / 4), Math.abs(mid2 - (3 * math_1.TAU) / 4));
        return dist1 - dist2;
    })
        .map(function (node) {
        var midAngle = math_1.trueBearingToStandardPositionAngle(geometry_1.meanAngle(node.x0, node.x1));
        var north = midAngle < math_1.TAU / 2 ? 1 : -1;
        var side = math_1.TAU / 4 < midAngle && midAngle < (3 * math_1.TAU) / 4 ? 0 : 1;
        var west = side ? 1 : -1;
        var cos = Math.cos(midAngle);
        var sin = Math.sin(midAngle);
        var x0 = cos * anchorRadius;
        var y0 = sin * anchorRadius;
        var x = cos * (anchorRadius + linkLabel.radiusPadding);
        var y = sin * (anchorRadius + linkLabel.radiusPadding);
        var poolIndex = side + (1 - north);
        var relativeY = north * y;
        currentY[poolIndex] = Math.max(currentY[poolIndex] + rowPitch, relativeY + yRelativeIncrement, rowPitch / 2);
        var cy = north * currentY[poolIndex];
        var stemFromX = x;
        var stemFromY = y;
        var stemToX = x + north * west * cy - west * relativeY;
        var stemToY = cy;
        var text = rawTextGetter(node);
        var valueText = valueFormatter(valueGetter(node));
        var labelFontSpec = __assign(__assign({ fontStyle: 'normal', fontVariant: 'normal', fontFamily: config.fontFamily, fontWeight: 'normal' }, linkLabel), { text: text });
        var valueFontSpec = __assign(__assign(__assign({ fontStyle: 'normal', fontVariant: 'normal', fontFamily: config.fontFamily, fontWeight: 'normal' }, linkLabel), linkLabel.valueFont), { text: valueText });
        var _a = measure(linkLabel.fontSize, [labelFontSpec])[0], width = _a.width, emHeightAscent = _a.emHeightAscent, emHeightDescent = _a.emHeightDescent;
        var valueWidth = measure(linkLabel.fontSize, [valueFontSpec])[0].width;
        return {
            link: [
                [x0, y0],
                [stemFromX, stemFromY],
                [stemToX, stemToY],
                [stemToX + west * linkLabel.horizontalStemLength, stemToY],
            ],
            translate: [stemToX + west * (linkLabel.horizontalStemLength + linkLabel.gap), stemToY],
            textAlign: side ? 'left' : 'right',
            text: text,
            valueText: valueText,
            width: width,
            valueWidth: valueWidth,
            verticalOffset: -(emHeightDescent + emHeightAscent) / 2,
            labelFontSpec: labelFontSpec,
            valueFontSpec: valueFontSpec,
        };
    });
}
exports.linkTextLayout = linkTextLayout;
//# sourceMappingURL=link_text_layout.js.map