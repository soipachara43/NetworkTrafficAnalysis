"use strict";
/*
 * Licensed to Elasticsearch B.V. under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch B.V. licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const url_1 = tslib_1.__importDefault(require("url"));
const axios_1 = tslib_1.__importDefault(require("axios"));
const axios_2 = require("../axios");
const isConcliftOnGetError = (error) => {
    return (axios_2.isAxiosResponseError(error) && error.config.method === 'GET' && error.response.status === 409);
};
exports.uriencode = (strings, ...values) => {
    const queue = strings.slice();
    if (queue.length === 0) {
        throw new Error('how could strings passed to `uriencode` template tag be empty?');
    }
    if (queue.length !== values.length + 1) {
        throw new Error('strings and values passed to `uriencode` template tag are unbalanced');
    }
    // pull the first string off the queue, there is one less item in `values`
    // since the values are always wrapped in strings, so we shift the extra string
    // off the queue to balance the queue and values array.
    const leadingString = queue.shift();
    return queue.reduce((acc, string, i) => `${acc}${encodeURIComponent(values[i])}${string}`, leadingString);
};
const DEFAULT_MAX_ATTEMPTS = 5;
const delay = (ms) => new Promise(resolve => {
    setTimeout(resolve, ms);
});
class KbnClientRequester {
    constructor(log, kibanaUrls) {
        this.log = log;
        this.kibanaUrls = kibanaUrls;
    }
    pickUrl() {
        const url = this.kibanaUrls.shift();
        this.kibanaUrls.push(url);
        return url;
    }
    resolveUrl(relativeUrl = '/') {
        return url_1.default.resolve(this.pickUrl(), relativeUrl);
    }
    async request(options) {
        var _a;
        const url = url_1.default.resolve(this.pickUrl(), options.path);
        const description = options.description || `${options.method} ${url}`;
        let attempt = 0;
        const maxAttempts = (_a = options.retries, (_a !== null && _a !== void 0 ? _a : DEFAULT_MAX_ATTEMPTS));
        while (true) {
            attempt += 1;
            try {
                const response = await axios_1.default.request({
                    method: options.method,
                    url,
                    data: options.body,
                    params: options.query,
                    headers: {
                        'kbn-xsrf': 'kbn-client',
                    },
                });
                return response.data;
            }
            catch (error) {
                const conflictOnGet = isConcliftOnGetError(error);
                const requestedRetries = options.retries !== undefined;
                const failedToGetResponse = axios_2.isAxiosRequestError(error);
                let errorMessage;
                if (conflictOnGet) {
                    errorMessage = `Conflict on GET (path=${options.path}, attempt=${attempt}/${maxAttempts})`;
                    this.log.error(errorMessage);
                }
                else if (requestedRetries || failedToGetResponse) {
                    errorMessage = `[${description}] request failed (attempt=${attempt}/${maxAttempts})`;
                    this.log.error(errorMessage);
                }
                else {
                    throw error;
                }
                if (attempt < maxAttempts) {
                    await delay(1000 * attempt);
                    continue;
                }
                throw new Error(`${errorMessage} -- and ran out of retries`);
            }
        }
    }
}
exports.KbnClientRequester = KbnClientRequester;
