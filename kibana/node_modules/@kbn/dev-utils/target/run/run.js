"use strict";
/*
 * Licensed to Elasticsearch B.V. under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch B.V. licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const util_1 = require("util");
// @ts-ignore @types are outdated and module is super simple
const exit_hook_1 = tslib_1.__importDefault(require("exit-hook"));
const tooling_log_1 = require("../tooling_log");
const fail_1 = require("./fail");
const flags_1 = require("./flags");
const proc_runner_1 = require("../proc_runner");
async function run(fn, options = {}) {
    var _a;
    const flags = flags_1.getFlags(process.argv.slice(2), options);
    if (flags.help) {
        process.stderr.write(flags_1.getHelp(options));
        process.exit(1);
    }
    const log = new tooling_log_1.ToolingLog({
        level: tooling_log_1.pickLevelFromFlags(flags),
        writeTo: process.stdout,
    });
    process.on('unhandledRejection', error => {
        log.error('UNHANDLED PROMISE REJECTION');
        log.error(error instanceof Error
            ? error
            : new Error(`non-Error type rejection value: ${util_1.inspect(error)}`));
        process.exit(1);
    });
    const handleErrorWithoutExit = (error) => {
        if (fail_1.isFailError(error)) {
            log.error(error.message);
            if (error.showHelp) {
                log.write(flags_1.getHelp(options));
            }
            process.exitCode = error.exitCode;
        }
        else {
            log.error('UNHANDLED ERROR');
            log.error(error);
            process.exitCode = 1;
        }
    };
    const doCleanup = () => {
        const tasks = cleanupTasks.slice(0);
        cleanupTasks.length = 0;
        for (const task of tasks) {
            try {
                task();
            }
            catch (error) {
                handleErrorWithoutExit(error);
            }
        }
    };
    const unhookExit = exit_hook_1.default(doCleanup);
    const cleanupTasks = [unhookExit];
    try {
        if (!((_a = options.flags) === null || _a === void 0 ? void 0 : _a.allowUnexpected) && flags.unexpected.length) {
            throw fail_1.createFlagError(`Unknown flag(s) "${flags.unexpected.join('", "')}"`);
        }
        try {
            await proc_runner_1.withProcRunner(log, async (procRunner) => {
                await fn({
                    log,
                    flags,
                    procRunner,
                    addCleanupTask: (task) => cleanupTasks.push(task),
                });
            });
        }
        finally {
            doCleanup();
        }
    }
    catch (error) {
        handleErrorWithoutExit(error);
        process.exit();
    }
}
exports.run = run;
