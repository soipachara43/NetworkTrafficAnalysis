"use strict";
/*
 * Licensed to Elasticsearch B.V. under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch B.V. licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const execa_1 = tslib_1.__importDefault(require("execa"));
const fs_1 = require("fs");
const Rx = tslib_1.__importStar(require("rxjs"));
const operators_1 = require("rxjs/operators");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const tree_kill_1 = tslib_1.__importDefault(require("tree-kill"));
const util_1 = require("util");
const treeKillAsync = util_1.promisify((...args) => tree_kill_1.default(...args));
const observe_lines_1 = require("./observe_lines");
const errors_1 = require("./errors");
const SECOND = 1000;
const STOP_TIMEOUT = 30 * SECOND;
async function withTimeout(attempt, ms, onTimeout) {
    const TIMEOUT = Symbol('timeout');
    try {
        await Promise.race([
            attempt(),
            new Promise((_, reject) => setTimeout(() => reject(TIMEOUT), ms)),
        ]);
    }
    catch (error) {
        if (error === TIMEOUT) {
            await onTimeout();
        }
        else {
            throw error;
        }
    }
}
function startProc(name, options, log) {
    const { cmd, args, cwd, env, stdin } = options;
    log.info('[%s] > %s', name, cmd, args.join(' '));
    // spawn fails with ENOENT when either the
    // cmd or cwd don't exist, so we check for the cwd
    // ahead of time so that the error is less ambiguous
    try {
        if (!fs_1.statSync(cwd).isDirectory()) {
            throw new Error(`cwd "${cwd}" exists but is not a directory`);
        }
    }
    catch (err) {
        if (err.code === 'ENOENT') {
            throw new Error(`cwd "${cwd}" does not exist`);
        }
    }
    const childProcess = execa_1.default(cmd, args, {
        cwd,
        env,
        stdio: ['pipe', 'pipe', 'pipe'],
        preferLocal: true,
    });
    if (stdin) {
        childProcess.stdin.end(stdin, 'utf8');
    }
    else {
        childProcess.stdin.end();
    }
    let stopCalled = false;
    const outcome$ = Rx.race(
    // observe first exit event
    Rx.fromEvent(childProcess, 'exit').pipe(operators_1.take(1), operators_1.map(([code]) => {
        if (stopCalled) {
            return null;
        }
        // JVM exits with 143 on SIGTERM and 130 on SIGINT, dont' treat then as errors
        if (code > 0 && !(code === 143 || code === 130)) {
            throw errors_1.createCliError(`[${name}] exited with code ${code}`);
        }
        return code;
    })), 
    // observe first error event
    Rx.fromEvent(childProcess, 'error').pipe(operators_1.take(1), operators_1.mergeMap(err => Rx.throwError(err)))).pipe(operators_1.share());
    const lines$ = Rx.merge(observe_lines_1.observeLines(childProcess.stdout), observe_lines_1.observeLines(childProcess.stderr)).pipe(operators_1.tap(line => log.write(` ${chalk_1.default.gray('proc')} [${chalk_1.default.gray(name)}] ${line}`)), operators_1.share());
    const outcomePromise = Rx.merge(lines$.pipe(operators_1.ignoreElements()), outcome$).toPromise();
    async function stop(signal) {
        if (stopCalled) {
            return;
        }
        stopCalled = true;
        await withTimeout(async () => {
            log.debug(`Sending "${signal}" to proc "${name}"`);
            await treeKillAsync(childProcess.pid, signal);
            await outcomePromise;
        }, STOP_TIMEOUT, async () => {
            log.warning(`Proc "${name}" was sent "${signal}" didn't emit the "exit" or "error" events after ${STOP_TIMEOUT} ms, sending SIGKILL`);
            await treeKillAsync(childProcess.pid, 'SIGKILL');
        });
        await withTimeout(async () => {
            try {
                await outcomePromise;
            }
            catch (error) {
                // ignore
            }
        }, STOP_TIMEOUT, async () => {
            throw new Error(`Proc "${name}" was stopped but never emitted either the "exit" or "error" event after ${STOP_TIMEOUT} ms`);
        });
    }
    return {
        name,
        lines$,
        outcome$,
        outcomePromise,
        stop,
    };
}
exports.startProc = startProc;
