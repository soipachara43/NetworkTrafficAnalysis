"use strict";
/*
 * Licensed to Elasticsearch B.V. under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch B.V. licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const moment_1 = tslib_1.__importDefault(require("moment"));
const operators_1 = require("rxjs/operators");
const exit_hook_1 = tslib_1.__importDefault(require("exit-hook"));
const errors_1 = require("./errors");
const proc_1 = require("./proc");
const noop = () => { };
/**
 *  Helper for starting and managing processes. In many ways it resembles the
 *  API from `grunt_run`, processes are named and can be started, waited for,
 *  backgrounded once they log something matching a RegExp...
 *
 *  @class ProcRunner
 */
class ProcRunner {
    constructor(log) {
        this.log = log;
        this.closing = false;
        this.procs = [];
        this.signalUnsubscribe = exit_hook_1.default(() => {
            this.teardown().catch(error => {
                log.error(`ProcRunner teardown error: ${error.stack}`);
            });
        });
    }
    /**
     *  Start a process, tracking it by `name`
     *  @param  {String}  name
     *  @param  {Object}  options
     *  @property {String} options.cmd executable to run
     *  @property {Array<String>?} options.args arguments to provide the executable
     *  @property {String?} options.cwd current working directory for the process
     *  @property {RegExp|Boolean} options.wait Should start() wait for some time? Use
     *                                          `true` will wait until the proc exits,
     *                                          a `RegExp` will wait until that log line
     *                                          is found
     *  @return {Promise<undefined>}
     */
    async run(name, options) {
        const { cmd, args = [], cwd = process.cwd(), stdin = undefined, wait = false, env = process.env, } = options;
        if (this.closing) {
            throw new Error('ProcRunner is closing');
        }
        if (wait && !(wait instanceof RegExp) && wait !== true) {
            throw new TypeError('wait param should either be a RegExp or `true`');
        }
        if (!!this.getProc(name)) {
            throw new Error(`Process with name "${name}" already running`);
        }
        const proc = this.startProc(name, {
            cmd,
            args,
            cwd,
            env,
            stdin,
        });
        try {
            if (wait instanceof RegExp) {
                // wait for process to log matching line
                await proc.lines$
                    .pipe(operators_1.filter(line => wait.test(line)), operators_1.first(), operators_1.catchError(err => {
                    if (err.name !== 'EmptyError') {
                        throw errors_1.createCliError(`[${name}] exited without matching pattern: ${wait}`);
                    }
                    else {
                        throw err;
                    }
                }))
                    .toPromise();
            }
            if (wait === true) {
                // wait for process to complete
                await proc.outcomePromise;
            }
        }
        finally {
            // while the procRunner closes promises will resolve/reject because
            // processes and stopping, but consumers of run() shouldn't have to
            // prepare for that, so just return a never-resolving promise
            if (this.closing) {
                await new Promise(noop);
            }
        }
    }
    /**
     *  Stop a named proc
     */
    async stop(name, signal = 'SIGTERM') {
        const proc = this.getProc(name);
        if (proc) {
            await proc.stop(signal);
        }
        else {
            this.log.warning('[%s] already stopped', name);
        }
    }
    /**
     *  Wait for all running processes to stop naturally
     *  @return {Promise<undefined>}
     */
    async waitForAllToStop() {
        await Promise.all(this.procs.map(proc => proc.outcomePromise));
    }
    /**
     *  Close the ProcRunner and stop all running
     *  processes with `signal`
     *
     *  @param  {String} [signal=undefined]
     *  @return {Promise}
     */
    async teardown(signal = 'exit') {
        if (this.closing) {
            return;
        }
        this.closing = true;
        this.signalUnsubscribe();
        if (!signal && this.procs.length > 0) {
            this.log.warning('%d processes left running, stop them with procs.stop(name):', this.procs.length, this.procs.map(proc => proc.name));
        }
        await Promise.all(this.procs.map(async (proc) => {
            await proc.stop(signal === 'exit' ? 'SIGKILL' : signal);
        }));
    }
    getProc(name) {
        return this.procs.find(proc => {
            return proc.name === name;
        });
    }
    startProc(name, options) {
        const startMs = Date.now();
        const proc = proc_1.startProc(name, options, this.log);
        this.procs.push(proc);
        const remove = () => {
            this.procs.splice(this.procs.indexOf(proc), 1);
        };
        // tie into proc outcome$, remove from _procs on compete
        proc.outcome$.subscribe({
            next: code => {
                const duration = moment_1.default.duration(Date.now() - startMs);
                this.log.info('[%s] exited with %s after %s', name, code, duration.humanize());
            },
            complete: () => {
                remove();
            },
            error: error => {
                if (this.closing) {
                    this.log.error(error);
                }
                remove();
            },
        });
        return proc;
    }
}
exports.ProcRunner = ProcRunner;
