"use strict";
/*
 * Licensed to Elasticsearch B.V. under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch B.V. licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const util_1 = require("util");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const log_levels_1 = require("./log_levels");
const { magentaBright, yellow, red, blue, green, dim } = chalk_1.default;
const PREFIX_INDENT = ' '.repeat(6);
const MSG_PREFIXES = {
    verbose: ` ${magentaBright('sill')} `,
    debug: ` ${dim('debg')} `,
    info: ` ${blue('info')} `,
    success: ` ${green('succ')} `,
    warning: ` ${yellow('warn')} `,
    error: `${red('ERROR')} `,
};
const has = (obj, key) => obj.hasOwnProperty(key);
function shouldWriteType(level, type) {
    if (type === 'write') {
        return true;
    }
    return Boolean(level.flags[type === 'success' ? 'info' : type]);
}
function stringifyError(error) {
    if (typeof error !== 'string' && !(error instanceof Error)) {
        error = new Error(`"${error}" thrown`);
    }
    if (typeof error === 'string') {
        return error;
    }
    return error.stack || error.message || error;
}
class ToolingLogTextWriter {
    constructor(config) {
        this.level = log_levels_1.parseLogLevel(config.level);
        this.writeTo = config.writeTo;
        if (!this.writeTo || typeof this.writeTo.write !== 'function') {
            throw new Error('ToolingLogTextWriter requires the `writeTo` option be set to a stream (like process.stdout)');
        }
    }
    write(msg) {
        if (!shouldWriteType(this.level, msg.type)) {
            return false;
        }
        const prefix = has(MSG_PREFIXES, msg.type) ? MSG_PREFIXES[msg.type] : '';
        ToolingLogTextWriter.write(this.writeTo, prefix, msg);
        return true;
    }
    static write(writeTo, prefix, msg) {
        const txt = msg.type === 'error'
            ? stringifyError(msg.args[0])
            : util_1.format(msg.args[0], ...msg.args.slice(1));
        (prefix + txt).split('\n').forEach((line, i) => {
            let lineIndent = '';
            if (msg.indent > 0) {
                // if we are indenting write some spaces followed by a symbol
                lineIndent += ' '.repeat(msg.indent - 1);
                lineIndent += line.startsWith('-') ? '└' : '│';
            }
            if (line && prefix && i > 0) {
                // apply additional indentation to lines after
                // the first if this message gets a prefix
                lineIndent += PREFIX_INDENT;
            }
            writeTo.write(`${lineIndent}${line}\n`);
        });
    }
}
exports.ToolingLogTextWriter = ToolingLogTextWriter;
